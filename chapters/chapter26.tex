\chapter{图论 - 路径和算法}

\begin{figure}[ht]
  \centering
  \includegraphics[width=1\linewidth]{asset/20230924051220.png}
\end{figure}

\newpage

在充分了解图的概念, 构成以及种类之后, 我们要开始进入稍微有点难度的部分了. 这节课, 咱们来了解一下路径和Dijkstra算法. 

\section{拓展: 顶点和边的互换}

在这节课正式开始之前, 我们对上一节课稍微扩充一些内容. 线下有小伙伴问我, 顶点和边的互换问题. 我是没想到会有小伙伴会往深层次去挖, 这样挺好. 

那既然问到了, 我就稍微讲一下. 顶点和边确实是可以互换的, 这代表了更深一层的抽象性. 就比如说图\ref{fig:img26_1}, 它是由这些顶点ABCDE以及这几条边构成的. 

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.5\linewidth]{asset/20230924051221.jpg}
  \caption{}
  \label{fig:img26_1}
\end{figure}

我们也可以把这个边给它重新定义一下, 比如我们把连接A、D的这条边在一个新的图里面把它当成一个顶点. 因为虽然说这个图它是由顶点和边构成的, 但是我们在定义它的时候并没有说到它必须得代表什么样的含义, 实际的含义是我们赋予给它的. 所以这里我完全可以用一个新图, 在这个新图里面顶点就代表这些边. 
可以使用数字1来表示原来的边为顶点, 然后A、B这条边我们用数字2来表示. 这里就有两个顶点了. 

之前的2、4这两条边都用A来链接, 在我们新的图里面就可以类比一下, 就可以把A所对应的这个顶点当做我们新图的这个边. 

我们知道边它对应着什么含义, 它是连接了两个顶点. 而在我们这个新图里面, 这个顶点是原来的这个图里面的边. 通过这样的方式去做了一个顶点和边的一个互换. 

本来呢不想说这个, 怕把大家给绕晕. 因为这个是更深一层, 更抽象一点点的这个含义. 所以如果大家能想到这层也非常好啊, 你要知道这个不是什么东西是永恒的, 没有什么东西是永恒的. 

不是这个边它永远是边, 它在另外一个图里面可以是一个结点, 而这个结点在另外一些图里面它可以是一个边. 

\section{最短路径问题}

OK, 让我们回到这节课要讲的内容里. 

在图中, 有一个最短路径问题, 非常的有意思, 也非常重要. 如果你曾学算法数据结构的话, 肯定会遇到这种问题. 我们今天就来探讨一下, 怎么样用图论的思想或者说角度去处理这种问题. 

首先我们有一个赋权图 \ref{fig:img26_2}, 这个图里面它是只对边去做了一个赋值. 这些边都有一个权重, 这些顶点ABCDE代表了不同的城市, 权重代表了不同城市间的一个距离. 我给定一个起点, 让你求从这个起点出发, 到剩下的任意一个点的最短路径. 这个要怎么求？

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.5\linewidth]{asset/20230924051221.jpg}
  \caption{}
  \label{fig:img26_2}
\end{figure}

可能如果是用肉眼去观察的话, 在这个图的结点数以及这个边数不是很多的时候我们看也能看出答案. 但是这个不是我们一个终极意义, 我们的一个终极意义是希望找到一种自动化的过程. 不管这个顶点数量有多少, 边的数量有多少, 都希望能让计算机按照我规定的方式去找到最短路径. 希望找到解决这一类办法的一个通解. 

所以问题来了, 就是如果我们是A点出发的话, 怎样去求到剩下的BCDE各个点的一个最短路径呢？从A到B, 他们俩确实直接相连的, 他这个A、B边的权重是4, 但我们会发现如果通过D来中转一下,A、D是2, B、D是1,  2+1等于3, 它是小于4的. 

所以在这个时候可能它最短路径不是A、B直接相连的这条边, 可能更好的选择是走D绕一下路. 对于这种比较复杂的情况, 我们应该怎么样去找？

\section{Dijkstra算法}

对于上面所提出的最短路径问题, 就需要提出一个算法了, 就是我们的Dijkstra算法. Dijkstra算法是解决这种路线规划问题, 最短路线问题非常有效的一种方法. 

他的思路就是, 首先我们先把顶点的集合V给分成两组, 一组是S, 一组是U. 

S是已解决的顶点的集合, 初始时只含有源点V0. 已解决就是从起点出发到S集合里面这些顶点的最短路径已经被求出来了, 这些点的我们称之为已解决. 

U是我们还未确定的顶点集合. 

将U中顶点按递增的次序加入道S中, 保证下面两点: 

\begin{itemize}
  \item 从源点V0到S中其他各顶点的长度都不大于从V0到U中任何顶点的最短路径长度. 
  \item 每个顶点对应一个距离值
\end{itemize}

定义好之后, 初始的时候我们只有这个起点, 人是待在起点的, 还是一个待出发的状态. 所以一开始S这个集合里面只有V0这个点, 在图里面它就是A. 接下来, 我们先看这个U,U中的顶点是按照递增的次序加入到S中, 也就是初始化的时候, 虽然这些U还是没有被解决, 但是在一开始的时候也赋予了U中的点到原点的一个初始距离. 

比如一开始的时候原点是连接了所有的这个顶点的, 这种情况下它就有一个初始值, 我们就按照这种初始值从小到大排列. 每一次去取一个在U当中和这个原点距离最短的那一个点出来. 

然后我们保证这个原点V0到S是不大于从V0到U中的任意一个点. 

S当中包含已经找到最短路径的点, 要确保U中不存在中转点, 使得从V0到这些中转点, 再从中转点到S里其他的一些点的距离比通过它这个中转要长. 

S中顶点: 从V0到此顶点的长度
U中顶点: 从V0到此顶点的只包括S中顶点作中间顶点的最短路径长度. 

每个顶点都对应一个距离值,这个距离值就是目前当下从起点V0到顶点所对应的一个最短距离. 

当然还有一点就是S中的顶点, 比如V1这个路径, 不一定是从V0直接到V1的, 可能是通过S中的其他点中转, 然后再到V1. V0先到V2, 然后再从V2到V1, 这是我们找到一个从V0到V1的一个最短路径. 它不一定是直接的, 这点大家要注意. 

S中的顶点, 这个距离值是什么呢？刚才说了, 每个顶点都对应了一个距离值. S中的这个顶点对应的距离值和U中的顶点对应的距离值是不太一样的. 

S中的顶点就是代表了从V0到这个点的最短路径的一个长度. 就是最短路径已经找出来了, 不管是V0直接到V1, 还是V0通过中转其他点到V1的, 总之最短距离是找着了. 

U中的顶点是从V0到这个顶点, 包括在S中的顶点作为中转点的一个最短路线. 

比方说, S中已经有V0、V1这两个点了, 现在U中有V2、V3. U中的这个V2对应的这个距离是什么意思呢？要么就是V0直接到V2, 有个直飞航班, 要么就是V0中转到V1, 从V1到达了V2. 

所以U中这些顶点对应的距离值如果有中转点的话, 中转点一定是属于S当中的. 

这就是Dijkstra算法的一个思路. 如果单纯看这个步骤会非常晕, 我们接下来看一下这个分步拆解是怎么样做的, 如图\ref{fig:img26_3}. 

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.7\linewidth]{asset/20230924051222.jpg}
  \caption{}
  \label{fig:img26_3}
\end{figure}

首先这里有两个集合, S和U.  S呢是已解决的, U是还没有找到最短路径的这些点. 

当然, 这里没有单纯的是用一个点表示, 我们是用这些距离来表示. 但是大家如果要看点的话看第二个, 就箭头指向的是第二个. 

虽然表示的都是距离, 也可以表示点. 比如A->B, 距离4其实针对的是B这一点, 我们刚才说了S和U是顶点的集合. 

有的人可能看到这里会有点晕, 所以我就说一下, 这里虽然写成了距离的形式, 但是他在表示距离的同时也可以代表距离对应的是哪一个点. 

我们一开始的时候就说到了S集合里面只有起点, 这里起点是A, 所以A到A距离就是0. 在起点都不用走就已经到了, 所以距离是0. 

在这里插一点, 就是S一开始初始化的时候是只有包含A这个点. 而且因为它是起点, 所以A到A的距离就是0, 这个很好理解. U里面的点, 比如说A到B, A到D, A到C, A到E这些距离, 一般是全部初始化正无穷. 

这里A到B等于4, A到D等于2是因为A可以直接到达两个点B和D, 现在有一个距离4. A、B之间本来的距离是正无穷, 现在我们已经找着了, A可以直接到B, 它有一个路径是是4, 所以4就取代了正无穷. 因为它是一个更短的路径, 4是远小于正无穷的, 所以这里用4来取代. 大家要注意在初始化的时候U里面的4个长度全部都是正无穷. 

然后再看, 由A可以直接到哪一些点. 和A直接相连的, 是B和D两个点, B和D是和A直接相连的, 我们就把A、D之间的这个距离, 这个权重和它原来的这个距离正无穷相比, 我们更新了一下数值. 

我们现在知道, 从A到B的距离不再是正无穷了, 它是4. 就是AB边的权重为4. 这里A、D这个距离是2, 不再是正无穷了；C和E呢, 因为A不是直接相连C和E的, 所以我们还是把它写成正无穷的形式. 

这就是第一步. 接下来, 我们来看一下在U的集合里面边长最短的是哪一条边. 是AD, 所以我们就把D这一点给它再摘出来. 因为它距离最短, 2、4、正无穷、正无穷, 2是最短的. 我们把D摘出来. 

第二步, D的这个距离最短距离就是2, 那好, D的最短距离就是2, 图\ref{fig:img26_4}. 

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.7\linewidth]{asset/20230924051223.jpg}
  \caption{}
  \label{fig:img26_4}
\end{figure}

接下来我们就要更新BCE的距离了. 很巧的是BCE三点都和D直接相连. 我们现在来做一个什么样的判断呢？先来看一下到B点, 原本A到B的距离我们在上一步是求出来的, 在上一步当中它最短的距离直航航班. A到B, 权重4, AB在上一步里面是4. 

接下来D已经是放在S里面, 然后从起点A出发到D的最短距离已经确定了是2. 所以我们现在就来看从A到D的这一部分路程, 再加上D到B的这个路程会不会比上一步得到的AB, 也就是现在得到的AB直行的路程要短. 一加发现2+1=3是小于4的, 所以在这步里面呢我们就把A到B的距离给它更新一下, 就由4更新成了3. 

同理, 我们再来看一下AC, 在上一步我们知道它本来是正无穷, 因为我们在上一步没法更新, A和C不直接相连, 所以还是初始化里面的那个正无穷. 现在D我们可以处理它, 因为D有直飞航班可以到C, 所以我们做同样的一个判断, 就是A到D的距离再加上D到C的距离会不会比上一步得到的AC的距离要小？结果是确实小,$ 2+1=3$小与正无穷. 在这里A到C的距离也被更新了, 更新成3. 

接下来再看E, 我们在上一步也知道AE本来还是初始化的正无穷. 因为A没法到E, 所以上一步判断不了, 就只能暂且保留初始化值. 

接下来我们可以去探索了, 因为D也有直飞E的航班, 所以我们来看一下, A到D, 然后D到E这两段路程加在一块会不会比上一步的从A到E的距离要短？$2+7=9$, 9小于正无穷, A到E, 我们这个距离也从正无穷更新成了9.

好, D也就处理完了, 和它相邻的这BCE三个点我们都已经处理完了, 所以就不用去看了. 接下来再看U里面还剩哪三个点, 分别是BCE. 

BCE, 我们看哪一个点对应的距离在U里面当下是最小的？而这里有两个相等的, AB是3, AC也是3. 这个都无所谓, 我们任选一个都OK. 我们就选B, 选了B之后, 我们知道AB通过上一步的判断, 最短路径是通过D来中转了一下, 然后到达了B. 所以AB在这里已经确定的最短路径不是从A直接到B, 而是我们从这个A转D再到了B. 这个B到起点的距离也已经确定了, 就是3. 之后起点到B这个距离就不再是4了. 按照最短路径找到的结果, 就按3来计算, \ref{fig:img26_5}. 

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.7\linewidth]{asset/20230924051224.jpg}
  \caption{}
  \label{fig:img26_5}
\end{figure}

然后我们把B拎出来, 看B还和U当中的哪一个点有直接的联系, 就是有边相连. 那就是C了. 

C在上一步得到的结论是由A中转D再到C的距离仅仅是3, 那我们来看, 现在尝试着从B中转到C, 能不能让这个距离更缩短一点. 结果A到B要花费4, B到C又是4, 所以4+4=8, 它是大于3的, 没有上一步那个解更优. 所以这个值还是保留下来了, 不做更新. 

然后是E, 因为B和E不直接相连, E也没有去做更新, 那接下来我们再重复之前的一个步骤. 

挑出来A到C等于3, 这个是已经确定了一个最短路径, 然后我们把这个C点给摘出来, 就进入我们的下一步, \ref{fig:img26_6}. 

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.7\linewidth]{asset/20230924051225.jpg}
  \caption{}
  \label{fig:img26_6}
\end{figure}

进入到下一步之后, C到起点A的这个最短路径都已经确定了, 接下来再看一下U当中和C相连的点只剩哪一个了?只有E了对吧,U当中只有一个E了,也就是我们可以把E也当做一个终点. 

之前我们讨论过A到E, 它是从D中转的. 先由A到D, 然后由D到E, 这是我们在判断D这个点的时候判断出来一个结果. 在那一步我们确定了E到A的最短距离是经D中转也就是$2+7=9$. 

我们现在再探讨点C, 能不能通过C点这个中转, 让A到E的距离更短呢？我们会发现A到C的距离是判断出来了, 是走D中转, 所以是ADC. 从A到C的距离, 再加上C到E的距离, 2+1+3=6, 6是小于9的. 所以我们也就把最后这一个点给更新了. 

在这里A到E的这条路径就是由9更新成了6. 它的实际路径是ADCE. \ref{fig:img26_7} 

\begin{figure}[ht]
  \centering
  \caption{}
  \label{fig:img26_7}
  \includegraphics[width=0.7\linewidth]{asset/20230924051226.jpg}
\end{figure}

至此为止我们就把所有的点都给它遍历一遍, 已经找出来了. 所以我们在这里就是找到了各个点到起点A的一个最短路径, 最短距离. 

当然了, 这个过程我不知道大家如果看每一步这个图解是不是会清楚很多. 如果单纯看那个算法思想确实复杂一点. 这个每一步的图解其实还是很容易理解的. 而且我们在实际操作当中, 也会弄一个数组. 

我们放在S中的这每一个点, 不光记录它到起点的最短路径, 还要记住这个最短路径上一个点或者说负结点是哪一个点. 

我们用一个数组去记录下来, 记录下来之后就会发现, C点的负结点是D. 然后那我们再来看D, 它的这个负结点就是A. 

那为什么要记录这些负结点呢？就是最后要求最短路径, 往往并不是让你直接求出这个距离, 求距离也许很简单, 我是希望能告诉我从A点出发经过哪些点到e. 只要我们能把每一个点放到S集合的同时, 把它的这个负结点给记录下来, 每一个点只需要记录它的负结点, 一个跟一个, 我们就可以把整个最短路径给找出来了. 

就像我们以前在中学排队的时候, 体育老师可能说过我们只要记住我们前面是谁
就行了. 前面是小张还是小王, 你就记住你前面一个人就行了, 其他你不用管. 那大家最终都能把这个队列给找出来. 

在这里其实也是一样的, 就是这个目的. 当我们把每一个点放进S集合的同时, 我们把负结点也放进最短路径的集合的时候, 是由哪个点到达这个点的这个负结点给它记下来, 我们就能反向推导出来. 

比如, E点, 我们记录下来它负结点是C, C的负结点是D, D的负结点是A. 所以ECDA, 再把它颠倒过来就是ADCE. 这个最短路径就找出来了. 这个最短距离也就求出来了. 

我们来看一段动图演示: 动图在PDF内不好展示, 可以\href{https://raw.githubusercontent.com/hivandu/notes/main/img/20230924051227.gif}{点击连接看原图}

这个过程其实和我刚才说的是一模一样的, 大家会注意红色的正无穷就代表了我们目前假设的从这个起点到这些点的一个距离的初始化的时候. 全部初始化成了正无穷. 

然后再根据每一步的判断, 不断的把这些点从U集合放到S集合里面, 然后以你放的点作为一个中转点, 就像一个跳板一样. 

你看哪些点是和你刚放入S中集合的点相连, 再看一下通过你刚放的这个点中转能不能让其他的点到起点的距离更短, 就不断的达到更新的效果. 

这个动图大家如果觉得比较快, 可以在此处下载稍微慢速一些的, 因为网站限制无法上传过多帧的动图. 还可以回看一下刚才每一步的一个详解. 

当然, Dijkstra算法也有一些不太适用的情况. 就是权重如果是有一个负的情况出现的话, 那这个算法它就没办法起到作用了. 

为什么呢？你比如说, 我要求这个A点到B点的一个最短路径, 我们会发现它有一个直飞航班, 从A到B的. \ref{fig:img26_9}. 

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.4\linewidth]{asset/20230924051228.jpg}
  \caption{}
  \label{fig:img26_9}
\end{figure}

这个权重是10, 但是我发现如果从a到c中转一下它变成了-70, 然后从c到b是40. 通过这种方式我们去走的话, 通过C中转, 这个路程就是-30. 而且这还不算完, -30, 我们再想一下, 这个-30我们是从a到b, 那我现在从b再回到a, $-30+10=-20$. 但是没关系, 我们再做一次这个循环, 就会发现从a到b的这个距离会越来越小. 

所以大家要记住, 在这里Dijkstra算法如果权重是一个负的情况的话, 他是不太适用的. 尤其是当你形成了这么一个圆圈, 在这个圈里面, 你只要循环一次就能这两个点之间的距离变小. 那你循环无限次, 它距离就能无限变小了. 这个是很显然不符合现实情况的. 这是一个需要大家注意的一个地方. 

好, 那到这里, 我们包括用最短路径问题引出了Dijkstra算法, 介绍了其思想和过程, 并且用它演示了一遍求最短路径的经过. 

下一节课, 是我们图论的最后一节课, 也是我们整个「人工智能数学篇」的最后一节课, 我们下一节课会来学习「树」, 了解一下最小生成树. 最后总结一下. 

不过不用觉得遗憾, 因为数学篇只是我们长征路上的一个起点, 我们现在完成了Python以及数学基础, 就要正式迈入人工智能的大门了. 